유니티의 C# 스크립트는 Monobehaviour를 상속받아 만들어지며,
이 클래스를 상속받은 클래스는 Scene에 있는 동안 엔진에서
일정한 흐름에 따라 자동으로 함수를 호출하는데 이 흐름을 생명주기라고 한다.

- 유니티 함수들의 흐름
    
    ![Untitled](Untitled.png)
    

---

## Editor

Reset : 오브젝트 생성 후 인스펙터 뷰에서 리셋을 눌러줄 때 실행된다.

객체의 속성을 초기화 값으로 설정해줄 때 사용한다.

---

## **Initialization(초기화)**

- Awake
    
    스크립트가 실행될 때 1번만 호출된다.
    
    오브젝트가 비활성화일 경우엔 호출되지 않지만
    
    스크립트가 비활성화인 경우엔 호출된다.
    
    게임의 상태 또는 변수 초기화로 사용한다.
    
    오브젝트의 초기화 또는 프리팹의 인스턴스화가 모두 진행된 직후에 호출되기 때문에
    
    Find 함수 호출의 안전성을 보장한다.
    
    코루틴으로 실행할수 없다.
    
- OnEnable
    
    오브젝트 또는 스크립트가 활성화 될 때마다 호출된다. 이벤트 연결 시 사용한다
    
    코루틴으로 실행할수 없다.
    
- Start
    
    스크립트가 활성화될 때 한번만 호출된다.
    
    오브젝트 또는 스크립트가 비활성화인 경우 호출되지 않는다.
    
    코루틴으로 실행할 수 있다.
    

---

## **Physics(물리)**

- Update
    
    매 프레임마다 호출되는 함수로 디바이스 성능이나 최적화 상황에 따라
    
    framerate(프레임 속도)가 변하므로 함수 호출 시간이 매번 달라진다.
    
    스크립트가 활성화되어 있어야 호출된다.
    
- FixedUpdate
    
    매 매서드 호출 간격이 다른 Update와 달리 FixedUpdate는 함수 호출 간격이
    
    일정하도록 도장된다. 매번 일정한 주기로 똑같은 연산을 처리해야하는
    
    물리 계산 및 업데이트 처리에 주로 사용되는 함수이다.
    
    또한 Rigidbody컴포넌트를 활용하는 코드의 실행은 FixedUpdate에서 이뤄지는 것이
    
    더 정확한 물리게산이 가능하다.
    
- LateUpdate
    
    모든 Update함수가 호출된 후 한번씩 호출된다.
    
    스크립트가 활성화되어 있어야 호출되며 주로 카메라 이동 로직에 사용된다.
    
- OnTrigger
    
    두 오브젝트의 충돌 체크를 하는 함수이다.
    
    물리 연산을 하지 않고 통과된다.
    
- OnColision
    
    두 오브젝트의 충돌 체크를 하는 함수이다 .
    
    물리 영향을 받으며 Rigidbody가 존재해야 충돌 감지가 가능하다.
    

---

## **Decommissioning(해제)**

- OnApplicationQuit
    
    응용 프로그램 종료 전 모든 오브젝트에서 호출된다.
    
    어플리케이션 종료 전 실행해야 할 코드를 정의하는데 사용된다
    
    예를들어 게임 진행상황 저장, 네트워크 연결 종료, 사용한 리소스 정리등에 사용된다
    
- OnDisable
    
    오브젝트 또는 스크립트가 비활성화 될 때마다 호출된다.
    
    이벤트 연결 종료 시 사용한다.
    
    코루틴으로 실행할 수 없다.
    
- OnDestroy
    
    오브젝트 생존 기간의 마지막 프레임이 업데이트 된 후 실행된다.
    

---

## 코루틴에 대하여..

위의 내용을 공부하며 코루틴이란 단어가 꽤 많이 나왔다.

그래서 코루틴에 대해 따로 조사해본 결과는 다음과 같다.

유니티에서의 코루틴은 실행을 일시 정지하고 제어를 유니티에 반환하지만

중단한 부분에서 다음 프레임을 계속할 수 있는 메서드이다.

### 코루틴의 사용 이유

유니티에서 특정 코드가 반복적으로 실행되기 위해선 Update문에 코드를 

작성하면 되는데 간혹 Update가 아닌 곳에서도 반복적으로 코드가 실행되어야 할 필요가 있을때가 있다 이럴때 코루틴을 사용한다.

또, 업데이트문은 매 프레임마다 반복적으로 실행되는 반면 코루틴은 자신이 

필요한 순간에만 반복하고 필요하지 않을때는 사용하지 않을수 있으며

또한 일정 시간동안 멈춰있다가 그 뒤에 실행하게하거나 특정 조건을 부여해 

코드가 실행되게 할 수 있다.

### 코루틴의 작성 방법

코루틴을 사용하기 위해선 크게 2가지의 필수 조건이 있다.

1. 코루틴은 IEnumerator이라는 반환형으로 시작해야 한다.
2. **yield retrun**이 반드시 함수 내부에 존재해야한다.
- yield return null 라인
    
    실행이 일시정지 되고 다음 프레임에서 다시시작되는 지점이다. 
    
- 코루틴의 사용 모습
    
    IEnumerator 함수이름()
    {
    
    **yield  return**// + 조건
        // 함수 내용
    
    }
    
    yield return 뒤 조건이라 쓰여있는것은 해당 조건이 입력되는 것에 따라
    
    코루틴의 동작을 다양하게 컨트롤 할 수 있다.
    
- yield return 의 종류
    - yield return null; : 다음 프레임에 실행 됨.
    - yield return new WaitForSeconds( float ); : 매개변수로 입력한 숫자에 해당하는
        
        초만큼 기다렸다가 실행됨.
        
    - yield return new WaitForSecondsRealtime( flaot ); : 매개변수로 입력한 숫자에
        
        해당하는 초만큼 기다렸다가 실행됨.
        
    - 5. yield break;
    - 그외 : yield return + new WaitForFixedUpdate / WaitForEndOfFrame 등…

yield return의 종류는 꽤나 다양한데 위의 종류에서 소개한 것들중 첫번째,두번째를

많이 사용하고 나머지는 필요에 따라 사용한다.

위 yield return의 종류중 2번과 3번의 차이점은

2번은 유니티당의 시간을 기준으로 체크하는것이고

3번은 현실의 시간을 기준으로 체크하는 것이다.

### Invoke보다 뛰어난점

일정 시간만큼 지연시켰다가 코드를 동작하게 한다는 점에서 Invoke와 동일한

기능을 가지고 있지만, 코루틴에만 있는 장점은

코루틴을 통해 Update문과 별개로 동작하는 또다른 서브루틴을 만들수도 있지만

그것 말고도 매개변수를 넘길 수 있다는 장점이 있다.

코루틴은 앞에 IEnumerator를 작성한다는 것 말고는 일반적인 메소드와 동일하기 때문에 

매개변수를 사용할 수 있다 따라서 굉장히 자유롭게 사용가능한게 코루틴이다.