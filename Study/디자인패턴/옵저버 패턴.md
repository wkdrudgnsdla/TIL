###### 옵저버 패턴?
옵저버 패턴은 객체간 일대다 의존관계를 정의하여, 한 객체의 상태가 바뀌면 그에 의존하는 다수의 객체에게 자동으로 알림을 보내고, 갱신되도록 하는 [[디자인 패턴]]이다.


#### 사용처
- 게임에서 **점수**, **체력**, **시간** 등이 바뀔 때
- UI나 효과(애니메이션)가 그 변화를 **즉시 반영**해야 할 때
- 서로 **너무 밀접하게** 연결하지 않고, 느슨하게 데이터를 주고받고 싶을 때
위와 같은 상황에서 주로 사용한다.


#### 옵저버 패턴의 구성 요소
- **주체(Subject)**
	주체는 상태를 관리하고, Observer목록을 보유한다.
	상태 변경 시 알림을 보내는 역할을 맡는다.
- **관찰자(Observer)**
	주체로부터 알림을 받아 자신의 상태를 갱신하는 [[인터페이스]]나 추상클래스를 의미한다.
- **구체적 주제 클래스**
	주체를 구현하고, 데이터를 보유한다.
- **구체적 관찰자 클래스**
	관찰자를 구현하고, 주체로부터 받은 업데이트를 처리한다.


##### 동작 흐름
옵저버 패턴의 동작 흐름은 아래와 같다
1. **구독**: Observer 객체가 Subject 의 `Register()` 메서드를 호출해 자신을 등록함.
2. **상태 변경**: Subject 에서 내부 상태(데이터)가 변경한다.
3. **알림(Notification)**: Subject 가 등록된 모든 Observer 에게 `Update()` 호출함.
4. **갱신(Update)**: Observer 가 알림을 받아 자신의 동작/데이터를 갱신한다.

위를 이해하기 쉽게 풀어보자면
**신문사가 Subject**이고 **신문 구독자들이 Observer**이라면
신문사에선 매일 신문 내용을 발행하며, 신문 구독자들은 신문을 받고 읽는 역할을 한다.
이때, 신문사가 **새 소식을 발행하면**, 구독 신청한 사람들한테 "신문 왔어요" 하고 **자동으로 배달**해 주는 것이라고 이해하면 쉽다.


#### 장단점
##### 장점
- 객체 간의 결합도가 낮아져 유지보수에 용이해진다.
- 런타임에 동적으로 구독/ 해제가 가능하다.

##### 단점
- 구독 해제를 깜빡하면 메모리 누수가 발생한다.
- 복잡한 이벤트 흐름에서는 디버깅에 어려움이 생길 수 있다.
