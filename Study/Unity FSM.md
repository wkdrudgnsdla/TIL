FSM(finite-state machine)은 상태를 기반으로 동작을 제어하는 방식을 구현하기 위한 패턴이다

FSM의 핵심은 단 하나의 상태만을 가진다는 점이다 상태를 기준으로 어떤 동작을 수행할지
결정하기 떄문에 현재 상태만 알 수 있으면 어떤 동작을 수행하려 하는지 명확하게
파악할 수 있고 구현이 쉽다는 장점이 있다.

---

예시로 몬스터를 들어 설명

몬스터의 행동은 3가지로 구분

## 1.Idle

- 아무런 행동 없이 대기하고 있는 상태
- 플레이어가 인지 가능한 범위 안에 있다면 Move상태로 전환
- 플레이어가 공격 가능한 범위 안에 있다면 Attack상태로 전환

## 2.Move

- 플레이어에게 이동하는 상태
- 플레이어가 인지 범위를 벗어나면 Idle상태로 전환
- 플레이어가 공격 가능한 거리에 있다면 Attack상태로 전환

## 3.Attack

- 플레이어를 공격하는 상태
- 플레이어가 인지 범위를 벗아나면 Idle상태로 전환
- 플레이어가 공격 가능거리를 벗어나고 인지범위에 있다면 Move상태로 전환

---

위처럼 여러개의 행동을 조건을 넣어 상황에 맞 실행시키며 AI를 구현한다

이러한FSM에는 장점과 단점이 있다.

## 장점과 특징

- AI개념을 프로그래머 외의 기획자 또는 다른 사람이 쉽게 확인 또는 설계 할 수 있다
- 직관적이다
- 리플렉션 기반으로 한 코드 내에서 빠르게 코딩할 수 있다
- 구현 방법이 단순하고 직관적이다, 상태는 Enum필드로 편하게 추가할 수 있다
- 상태의 메서드는 밑줄 규칙(상태면_메서드명)으로 정의된다
    
    예시:Player_Attack
    

## 단점

- 확장이 힘들다
    
    단점에서의 확장이 힘들다는 말은 FSM의 상태를 추가하다보면
    
    다시 연결하기가 복잡하다는 뜻이다.
    
- 고지능의 ai를 만드는 것에는 한계가 있다
    - 예시로 상태에 따라 도주하는 AI를 만드록싶다고 했을때 그에 관련된 상태의 전이를
        
        만들어 줘야 한다 이러한 상황을 여러개 만들고 싶다면 그만큼 관리해야 할게 많다는 문제가 있다
        
- 많은 상태전이는 오버헤드가 발생할 가능성이 있다.
    
    (오버헤드란 스케줄링하는 시점부터 완료되는 시점까지 CPU가 잡을 실행하지
    
    않고 대기잡의 차단을 해제하며 소요하는 모든시간을 의미)
    

---

## FSM 예시 코드

- 코드
    
    using UnityEngine;
    
    public class Monster : MonoBehaviour
    
    {
    
    public enum State
    
    {
    
    Idle,
    
    Move,
    
    Attack
    
    }
    
    private State_state;
    
    private void Start()
    {
    
    _state = State.Idle;
    
    }
    
    private void Update()
    
    {
    
    switch(_state)
    
    {
    
    case State.Idle;
    
    //여기에 Idle상태의 목록을 사용
    
    break;
    
    case State.Move;
    
    //여기에 Move상태의 목록을 사용
    
    break;
    
    case State.Attack;
    
    //여기에 Attack상태의 목록을 사용
    
    break;
    
    }
    
    }
    
    }
    

위의 코드에서 열거형을 나타내는 enum을 통해 여러 잡들을 편리하게 생성한 뒤

업데이트에서 스위치문을 이용해 현재 상태에 따라 다른 동작을 실행한다.

업데이트 내에서 스위치문을 사용하기에 매 프레임마다 _state값에 따라 다른 동작을

실행하게 된다.