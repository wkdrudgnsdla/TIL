C#이 다중상속을 지원하지 않는데, 이유는 아래와 같다
- 다중상속은 이점이 없지만 너무 **복잡함**
- 부모 자식간 **충돌**할 가능성이 높다
- 구현에 많은 **부담**을 주며, **실행 속도 저하**가 발생한다
- 
따라서 다중 상속이 아닌 **Interface**를 이용해서 여러 특성을 상속받는 방법을 이용한다.

## 목차
---

**1.인터페이스 개념**

**2.사용방법**

**1.주의사항**

**3.장점 및 단점**

## 1.인터페이스(Interface)개념

---

인터페이스는 C#의 주요 기능이다.

기본적으로 **함수정의**, **프로퍼티(get, set) 정의** 같은걸 구현없이 할 수 있도록 도와준다.

따라서 인터페이스는 구현 없이 명시만 하기 때문에 인터페이스를 상속받은 자식들은 
반드시 명시한 것을 **재구현** 해야한다.

이러한 인터페이스의 구현 안해도 되는 특징은 복잡한 구조를 단순화 시키는
추상화와 비슷하다.

하지만 추상클래스와 인터페이스는 명백히 구분해야한다.

- 추상클래스 VS 인터페이스
    
    추상 클래스는 상속을 받아 기능을 이용하거나 확장을 하기 위함이고
    
    인터페이스는 구현의 강제에 목적을 두어, 구현 객체의 같은 동작을 보장한다는 데에 있다.
    
    둘의 가장 큰 차이는 인터페이스의 장점인 **다중상속** 유무이다.
    

## 2.사용방법

---

선언은 interface라는 키워드로 선언한다.

무조건 public으로 사용

이름은 클래스와 구분하기 위해서 앞에 대문자 I를 붙인다.

***IAttack 뒤에 able을 붙여 확실하게 하는게 좋다**

```csharp
public interface IAttack
{

}
```

위의 코드와 비슷한 모습으로 작성

안에 들어가는 내용은 메서드, 인덱서, 프로퍼티, 이벤트가 들어간다

```csharp
public interface IItem
{
    void Use(GameObject target);
}
```

이런 인터페이스 코드가 있다면

```csharp
public class HpPotion : MonoBehaviour, IItem
{
    public int amount = 100;
    
    public void Use(GameObject target)
    {
    	Debug.Log($"{amount}만큼 hp 회복!");
    }
}
```

HpPotion이라는 스크립트에서 void Use부분을 받아와서 사용하는걸 만들고

```csharp
OnTriggerEnter(Collider other)(
{
    IItem item = other.GetComponent<IItem>();
    
    if(item != null)
    	item.Use();       
}
```

이런식으로 가져오는느낌?

***주의할점**

단순한 변수는 멤버로 사용이 불가능하다 꼭 프로퍼티로 사용해야한다.

멤버들은 구현없이 선언만 가능하다.

## 3.장점 및 단점

---

### 1.장점

- **코드의 유연성 및 확장성** : 인터페이스는 구현 방식을 구체적으로 정의하지 않고, 그 클래스가 제공해야하는 메서드나 속성의 형태만 정의한다.
  
    이를 통해 여러 클래스가 같은 인터페이스를 구현할 수 있기 때문에 코드의 유연성과 확장성이 증가한다.
    
- **의존성 감소** : 인터페이스를 사용하면 클래스는 다른 클래스의 구체적인 구현에 의지하지 않고
    인터페이스를 통해 상호작용 한다.
    이는 특정 클래스의 구현이 변경되어도 다른 클래스에 미치는
    영향을 최소화 할 수 있다
    
- **다형성** : 인터페이스를 사용하면 클래스들이 같은 타입으로 처리될 수 있다.
	  
    인터페이스를 타입으로 사용하여 그 인터페이스를 사용하는 클래스들이 다양하게 처리될 수 있게 한다.

### 2.단점

- **코드 복잡도 증가** : 인터페이스를 남발하거나 필요 이상으로 사용하면 불필요하게 코드를
    복잡하게 만들 수 있다. 단순한 코드를 작성하는 경우, 인터페이스를 이용하면 
    오히려 코드를 이해하기 어렵게 만들고, 유지보수에 필요한 시간이 증가할 수 있다.

- **구현 강제성** : 인터페이스를 구현하는 모든 클래스는 인터페이스에서 정의한
    모든 멤버 즉 내용들을 구현해야 한다. 이로인해 필요하지 않은 메서드나, 속성을 구현해야하는 상황이 발생할 수 있으며, 이는 불필요한 코드가 증가하는 결과를 초래할 수 있다.
    

- **추적 어려움** : 인터페이스를 사용하면 클래스간의 연결이 약해지므로  코드가 많아질수록
    어디에서 어떤 클래스가 특정 인터페이스를 구현하는지 알기 어려워질 수 있다.
    

- .
    
    프로퍼티는 클래스 필드에 접근을 제어하는 방법
    인덱서는 배열의 특성을 가진 프로퍼티의 일종